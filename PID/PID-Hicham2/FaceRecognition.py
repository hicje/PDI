# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Vs2y-AUmcKIqzOJo9VduYyA-ecw3Hv6v
"""

import cv2
import numpy as np
from matplotlib import pyplot as plt
from google.colab import files
import os

# Carregar o classificador Haar Cascade para detecção de faces
face_cascade = cv2.CascadeClassifier('haarcascade_frontalface_default.xml')

# Verificar se o classificador foi carregado corretamente
if face_cascade.empty():
    # Baixar o arquivo Haar Cascade se não estiver presente
    !wget https://raw.githubusercontent.com/opencv/opencv/master/data/haarcascades/haarcascade_frontalface_default.xml
    face_cascade = cv2.CascadeClassifier('haarcascade_frontalface_default.xml')

# Solicitar o upload das imagens de rostos conhecidos
print("\nAgora, faça o upload das imagens de rostos **conhecidos**.")
uploaded_known = files.upload()

# Inicializar listas de rostos conhecidos e seus labels
known_faces = []
known_labels = []
label_dict = {}
current_label = 0

# Carregar e processar as imagens de rostos conhecidos
for file_name in uploaded_known.keys():
    img = cv2.imread(file_name)
    if img is not None:
        gray_img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
        faces = face_cascade.detectMultiScale(
            gray_img, scaleFactor=1.1, minNeighbors=5, minSize=(30, 30)
        )
        if len(faces) > 0:
            (x, y, w, h) = faces[0]
            face_region = gray_img[y:y + h, x:x + w]
            face_resized = cv2.resize(face_region, (200, 200))  # Redimensionar para um tamanho padrão

            # Não aplicar equalização ou alinhamento

            # Não aplicar data augmentation
            augmented_faces = [face_resized]

            name = file_name.split('.')[0]  # Obter o nome sem a extensão

            if name not in label_dict:
                label_dict[name] = current_label
                current_label += 1

            label = label_dict[name]

            for aug_face in augmented_faces:
                known_faces.append(aug_face)
                known_labels.append(label)
        else:
            print(f"Nenhum rosto detectado em {file_name}.")
    else:
        print(f"Erro ao carregar a imagem conhecida {file_name}.")

# Verificar se temos rostos conhecidos para treinar
if len(known_faces) == 0:
    print("Nenhum rosto conhecido foi carregado. O programa será encerrado.")
else:
    # Criar o reconhecedor de faces LBPH
    recognizer = cv2.face.LBPHFaceRecognizer_create()

    # Converter as listas em formatos apropriados
    known_faces = [np.array(face, dtype=np.uint8) for face in known_faces]
    known_labels = np.array(known_labels)

    # Treinar o reconhecedor
    recognizer.train(known_faces, known_labels)

    # Solicitar o upload das imagens de teste
    print("\nPor favor, faça o upload das imagens de **teste**.")
    uploaded_test = files.upload()

    # Carregar e processar as imagens de teste
    test_images = []
    for file_name in uploaded_test.keys():
        image = cv2.imread(file_name)
        if image is not None:
            test_images.append((file_name, image))
        else:
            print(f"Erro ao carregar a imagem de teste {file_name}.")

    # Percorrer cada imagem de teste
    for test_file_name, test_image in test_images:
        gray_image = cv2.cvtColor(test_image, cv2.COLOR_BGR2GRAY)
        faces_in_test_image = face_cascade.detectMultiScale(
            gray_image, scaleFactor=1.1, minNeighbors=5, minSize=(30, 30)
        )

        # Verificar se foram detectados rostos na imagem de teste
        if len(faces_in_test_image) == 0:
            print(f"Nenhum rosto detectado na imagem de teste {test_file_name}.")
            continue

        # Percorrer cada rosto detectado na imagem de teste
        for (x, y, w, h) in faces_in_test_image:
            face_detected = gray_image[y:y + h, x:x + w]
            face_resized = cv2.resize(face_detected, (200, 200))  # Redimensionar para o mesmo tamanho

            # Não aplicar equalização ou alinhamento

            # Usar o reconhecedor para prever o label
            label, confidence = recognizer.predict(face_resized)

            # Obter o nome correspondente ao label
            name = None
            for key, value in label_dict.items():
                if value == label:
                    name = key
                    break

            # Definir um limiar de confiança
            threshold = 80  # Ajuste conforme necessário

            if confidence > threshold:
                name = "Desconhecido"

            print(f"Label previsto: {label}, Nome: {name}, Confiança: {confidence}")

            # Desenhar o retângulo e o nome
            cv2.rectangle(test_image, (x, y), (x + w, y + h), (255, 0, 0), 2)
            cv2.putText(
                test_image,
                name if name else "Desconhecido",
                (x, y - 10),
                cv2.FONT_HERSHEY_SIMPLEX,
                0.8,
                (255, 255, 255),
                2
            )

        # Exibir a imagem com as faces identificadas
        plt.figure(figsize=(10, 8))
        plt.imshow(cv2.cvtColor(test_image, cv2.COLOR_BGR2RGB))
        plt.title(f"Resultado para {test_file_name}")
        plt.axis('off')
        plt.show()

    # Limpar todos os arquivos de imagem
    for file_name in list(uploaded_test.keys()) + list(uploaded_known.keys()):
        try:
            os.remove(file_name)
            print(f"Arquivo {file_name} removido.")
        except FileNotFoundError:
            print(f"Arquivo {file_name} não encontrado para remoção.")